---
description: 
globs: 
alwaysApply: false
---
Хорошо, вот набор концептуальных правил для Cursor IDE, основанный на предоставленной информации, с акцентом на автоматизацию разработки Flask-приложений с интеграцией Figma. Эти правила описаны в формате "ЕСЛИ [триггер/условие] ТОГДА [действие]", отражая логику, описанную в тексте.

**Примечание:** Это концептуальные правила. Фактическая реализация в Cursor IDE потребует использования специфического синтаксиса и API Cursor, а также, возможно, написания скриптов (например, на Python) для взаимодействия с Figma API и генерации кода.

---

## Концептуальные правила Cursor IDE для автоматизации Flask + Figma

### 1. Настройка проекта Flask

* **Правило: Инициализация структуры Flask-проекта**
    * **ЕСЛИ:** Пользователь выполняет команду "Создать новый Flask проект" ИЛИ создает пустой каталог с намерением использовать Flask (например, через специальный маркерный файл `.flaskproject`).
    * **ТОГДА:**
        * Создать каталоги: `templates/`, `static/css/`, `static/js/`, `static/img/`, (опционально) `models/`, `forms/`.
        * Создать файл `app.py` с базовым импортом Flask и инициализацией приложения (`app = Flask(__name__)`).
        * Создать файл `config.py` с базовыми настройками (например, `SECRET_KEY`, `DEBUG`).
        * Создать базовый шаблон `templates/base.html` (например, с блоками `head`, `content`, `scripts`).
        * Создать пустой `static/css/style.css`.
        * (Опционально) Создать `requirements.txt` с `Flask`.

### 2. Интеграция с Figma и генерация маршрутов

* **Правило: Создание маршрута Flask и шаблона из экрана Figma**
    * **ЕСЛИ:** Пользователь предоставляет ссылку/ID экрана Figma ИЛИ использует команду "Создать маршрут из экрана Figma: [Имя Экрана]".
    * **ТОГДА:**
        * Извлечь имя экрана `[Имя Экрана]` (очистить его для использования в URL и имени функции, например, "User Profile" -> `user_profile`).
        * В `app.py` добавить новый маршрут:
            ```python
            @app.route('/[url_name]')
            def [function_name]():
                # TODO: Add logic
                return render_template('[template_name].html')
            ```
            (где `url_name`, `function_name`, `template_name` основаны на `[Имя Экрана]`).
        * Создать пустой файл шаблона `templates/[template_name].html`, наследующийся от `base.html`.
        * **Примечание:** Требуется соглашение об именовании экранов в Figma.

### 3. Генерация HTML/CSS из компонентов Figma

* **Правило: Трансляция базового элемента Figma в HTML**
    * **ЕСЛИ:** Пользователь предоставляет данные слоя Figma (например, через API или вставленный JSON/описание) И тип слоя - "TEXT".
    * **ТОГДА:** Сгенерировать соответствующий HTML-тег (`<p>`, `<h1>`-`<h6>`, `<span>` - возможно, на основе стиля текста в Figma) с содержимым текста слоя.
        * Пример: `ЕСЛИ` стиль текста "Heading 1" `ТОГДА` `<h1>[Текст слоя]</h1>`.
    * **ЕСЛИ:** Тип слоя - "FRAME" или "RECTANGLE" или "GROUP".
    * **ТОГДА:** Сгенерировать `<div>` или `<section>` (возможно, на основе имени слоя). Рекурсивно применить правила к дочерним слоям.

* **Правило: Трансляция компонента Figma "Кнопка" в HTML/CSS**
    * **ЕСЛИ:** Пользователь предоставляет данные компонента Figma И тип компонента - "Button" (или имя соответствует паттерну, например, "btn-*").
    * **ТОГДА:**
        * Извлечь текст кнопки `[метка]`.
        * Сгенерировать HTML: `<button class="[сгенерированный_класс]">{{ [метка] }}</button>` (или `<input type="submit">` если внутри формы).
        * **Вариант 1 (Прямые стили):** Извлечь стили (фон, цвет текста, граница, скругление) из Figma и сгенерировать CSS для класса `[сгенерированный_класс]` в `style.css`.
        * **Вариант 2 (Фреймворк):** Сопоставить стили Figma с классами CSS-фреймворка (например, Tailwind/Bootstrap): `ЕСЛИ` фон синий `И` стиль соответствует "Primary Button" `ТОГДА` добавить класс `btn btn-primary` (для Bootstrap) или `bg-blue-500 text-white font-bold py-2 px-4 rounded` (для Tailwind).
        * **Примечание:** Требуется четкое именование компонентов и стилей в Figma.

* **Правило: Трансляция компонента Figma "Поле ввода" в HTML**
    * **ЕСЛИ:** Пользователь предоставляет данные компонента Figma И тип/имя соответствует "Input Field" / "Text Input" / "Email Input" и т.д.
    * **ТОГДА:**
        * Сгенерировать HTML: `<input type="[тип]" name="[имя_поля]" placeholder="[текст-заполнитель]">`.
        * Определить `[тип]` (text, email, password) на основе имени или свойств компонента в Figma.
        * Определить `[имя_поля]` (например, из имени слоя).
        * Извлечь `[текст-заполнитель]` из Figma.
        * (Опционально) Если рядом есть текстовый слой-метка, сгенерировать `<label for="[имя_поля]">[Текст метки]</label>`.
        * Применить стили (Вариант 1 или 2, как для кнопки).

* **Правило: Трансляция фрейма Figma "Форма" в HTML**
    * **ЕСЛИ:** Пользователь предоставляет данные фрейма Figma И имя фрейма содержит "Form" или имеет специальное свойство.
    * **ТОГДА:**
        * Сгенерировать тег `<form method="POST" action="{{ url_for('[имя_маршрута_обработчика]') }}">`.
        * Добавить CSRF-токен Flask: `{{ form.csrf_token }}` (если используется Flask-WTF).
        * Рекурсивно обработать дочерние элементы (поля ввода, кнопки) с помощью соответствующих правил.
        * **Примечание:** Требуется определить `[имя_маршрута_обработчика]`.

### 4. Связывание Frontend и Backend (Базовое)

* **Правило: Генерация обработчика формы Flask**
    * **ЕСЛИ:** HTML-форма была сгенерирована ИЛИ пользователь вызывает команду "Создать обработчик для формы [имя_формы]".
    * **ТОГДА:**
        * В `app.py`, в соответствующем маршруте (или создать новый POST-маршрут), добавить логику обработки:
            ```python
            if request.method == 'POST':
                field1 = request.form.get('[имя_поля1]')
                field2 = request.form.get('[имя_поля2]')
                # TODO: Add validation and processing logic
                # ...
                return redirect(url_for('[маршрут_успеха]'))
            ```
        * Использовать имена полей (`[имя_поля1]`, `[имя_поля2]`), сгенерированные на шаге создания полей ввода.
        * **Примечание:** Это базовая генерация, валидация и сложная логика требуют ручной доработки. Рассмотреть интеграцию с Flask-WTF для автоматической генерации классов форм.

* **Правило: Передача базовых данных в шаблон**
    * **ЕСЛИ:** В дизайне Figma есть элементы, явно помеченные для отображения данных (например, слой с именем "data:user_name").
    * **ТОГДА:**
        * В соответствующем маршруте Flask в `app.py` добавить передачу переменной в контекст:
            ```python
            def [function_name]():
                user_name = "Default Name" # TODO: Get actual data
                return render_template('[template_name].html', user_name=user_name)
            ```
        * В шаблоне `[template_name].html` использовать переменную Jinja2: `{{ user_name }}`.
        * **Примечание:** Очень зависит от соглашений именования в Figma.

### 5. Управление стилями

* **Правило: Импорт цветовых стилей Figma как CSS-переменных**
    * **ЕСЛИ:** Пользователь выполняет команду "Импортировать цвета из Figma" И предоставлен доступ к API Figma / файл экспорта стилей.
    * **ТОГДА:**
        * Извлечь определенные в Figma цветовые стили (например, "Primary Color", "Accent Color").
        * В `static/css/variables.css` (или аналогичный файл) сгенерировать CSS-переменные:
            ```css
            :root {
              --primary-color: #[цвет_hex];
              --accent-color: #[цвет_hex];
              /* ... другие цвета */
            }
            ```
        * Убедиться, что этот CSS-файл подключен в `base.html`.

* **Правило: Импорт стилей типографики Figma как CSS-классов**
    * **ЕСЛИ:** Пользователь выполняет команду "Импортировать типографику из Figma" И предоставлен доступ к API Figma / файл экспорта стилей.
    * **ТОГДА:**
        * Извлечь определенные в Figma стили текста (например, "Heading 1", "Body Text").
        * В `static/css/typography.css` (или аналогичный файл) сгенерировать CSS-классы:
            ```css
            .text-heading-1 {
              font-family: '[Шрифт]';
              font-size: [Размер]px;
              font-weight: [Насыщенность];
              /* ... другие свойства */
            }
            .text-body {
              /* ... */
            }
            ```
        * Убедиться, что этот CSS-файл подключен в `base.html`.

---

**Важные соображения:**

1.  **Зависимость от Figma:** Эффективность правил сильно зависит от структуры и именования элементов/компонентов/стилей в Figma. Необходимы четкие соглашения между дизайнерами и разработчиками.
2.  **API Figma:** Для максимальной автоматизации (особенно для стилей и структуры) потребуется интеграция с Figma API, что включает аутентификацию и обработку данных API. Альтернатива – ручной экспорт/копирование данных из Figma.
3.  **Гибкость vs. Жесткость:** Правила должны быть достаточно гибкими, чтобы обрабатывать вариации в дизайне, но достаточно конкретными, чтобы генерировать полезный код. Может потребоваться параметризация и условная логика в правилах.
4.  **CSS-фреймворки:** Использование фреймворков (Tailwind, Bootstrap) упрощает маппинг стилей по сравнению с генерацией "сырого" CSS из Figma. Правила должны поддерживать выбранный фреймворк.
5.  **Итеративность:** Начинать следует с автоматизации самых рутинных задач (структура проекта, базовые компоненты) и постепенно усложнять правила.

6.  **Ограничения:** Полностью автоматизировать сложную логику приложения или нетривиальные UI-взаимодействия только на основе дизайна Figma и правил IDE маловероятно. Правила служат для ускорения создания *каркаса* и *базовых* элементов.